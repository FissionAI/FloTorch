AWSTemplateFormatVersion: '2010-09-09'
Description: 'Lambda Function Template for Flotorch'

Parameters:
  TableSuffix:
    Type: String
    Description: Suffix to append to resource names
  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: VPC ID where Lambda functions will be deployed
  PrivateSubnets:
    Type: List<AWS::EC2::Subnet::Id>
    Description: Private subnet IDs for Lambda functions
  DataBucketName:
    Type: String
    Description: Name of the S3 bucket for data storage
  ExecutionTableName:
    Type: String
    Description: Name of the DynamoDB execution table
  ExperimentTableName:
    Type: String
    Description: Name of the DynamoDB experiment table
  MetricsTableName:
    Type: String
    Description: Name of the DynamoDB metrics table
  ModelInvocationsTableName:
    Type: String
    Description: Name of the DynamoDB model invocations table
  OpenSearchEndpoint:
    Type: String
    Description: OpenSearch domain endpoint
  OpenSearchAdminUser:
    Type: String
    Description: OpenSearch admin username
  OpenSearchAdminPassword:
    Type: String
    Description: OpenSearch admin password
    NoEcho: true
  IndexingRepositoryUri:
    Type: String
    Description: URI for the indexing repository
  RetrieverRepositoryUri:
    Type: String
    Description: URI for the retriever repository
  AppRepositoryUri:
    Type: String
    Description: URI for the app repository
  EvaluationRepositoryUri:
    Type: String
    Description: URI for the evaluation repository
  RuntimeRepositoryUri:
    Type: String
    Description: URI for the runtime repository
  CostComputeRepositoryUri:
    Type: String
    Description: URI for the AI repository
  PublicSubnet1:
    Type: AWS::EC2::Subnet::Id
    Description: First public subnet ID
  PrivateSubnet1:
    Type: AWS::EC2::Subnet::Id
    Description: First private subnet ID
  IndexingImageTag:
    Type: String
    Description: Tag for the indexing image
  RetrieverImageTag:
    Type: String
    Description: Tag for the retriever image
  AppImageTag:
    Type: String
    Description: Tag for the app image
  EvaluationImageTag:
    Type: String
    Description: Tag for the evaluation image
  RuntimeImageTag:
    Type: String
    Description: Tag for the runtime image
  CostComputeImageTag:
    Type: String
    Description: Tag for the AI image

Resources:
  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Lambda functions
      GroupName: !Sub LambdaSecurityGroup-${TableSuffix}
      VpcId: !Ref VpcId
      SecurityGroupEgress:
        - IpProtocol: -1
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub FlotorchLambdaRole-${TableSuffix}
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonOpenSearchServiceFullAccess
        - arn:aws:iam::aws:policy/AmazonOpenSearchIngestionFullAccess
        - arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess
        - arn:aws:iam::aws:policy/AmazonS3FullAccess
      Policies:
        - PolicyName: LambdaVPCPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:CreateNetworkInterface
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DeleteNetworkInterface
                  - ec2:AssignPrivateIpAddresses
                  - ec2:UnassignPrivateIpAddresses
                Resource: '*'
        - PolicyName: LambdaDynamoDBPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:*
                Resource:
                  - !Sub arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ExecutionTableName}
                  - !Sub arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ExperimentTableName}
                  - !Sub arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${MetricsTableName}
                  - !Sub arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ModelInvocationsTableName}
                  - !Sub arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ExecutionTableName}/index/*
                  - !Sub arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ExperimentTableName}/index/*
                  - !Sub arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${MetricsTableName}/index/*
                  - !Sub arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ModelInvocationsTableName}/index/*
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !Sub arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ExecutionTableName}
                  - !Sub arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ExperimentTableName}

  DockerPullPushRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: EC2AndSSMAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:RunInstances
                  - ec2:DescribeInstances
                  - ec2:TerminateInstances
                  - ec2:CreateTags
                  - iam:PassRole
                  - ssm:SendCommand
                  - ssm:GetCommandInvocation
                Resource: '*'

  EC2InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyName: ECRAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:*
                Resource: '*'

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref EC2InstanceRole

  DockerPullPushFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt DockerPullPushRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import time
          import os

          def handler(event, context):
              try:
                  if event['RequestType'] in ['Create', 'Update']:
                      ec2 = boto3.client('ec2')
                      ssm = boto3.client('ssm')
                      
                      account_id = context.invoked_function_arn.split(":")[4]
                      region = os.environ['AWS_REGION']
                      table_suffix = event['ResourceProperties']['TableSuffix']
                      indexing_repository_uri = event['ResourceProperties']['IndexingRepositoryUri']
                      retriever_repository_uri = event['ResourceProperties']['RetrieverRepositoryUri']
                      app_repository_uri = event['ResourceProperties']['AppRepositoryUri']
                      evaluation_repository_uri = event['ResourceProperties']['EvaluationRepositoryUri']
                      runtime_repository_uri = event['ResourceProperties']['RuntimeRepositoryUri']
                      ai_repository_uri = event['ResourceProperties']['CostComputeRepositoryUri']
                      indexing_image_tag = event['ResourceProperties']['IndexingImageTag']
                      retriever_image_tag = event['ResourceProperties']['RetrieverImageTag']
                      app_image_tag = event['ResourceProperties']['AppImageTag']
                      evaluation_image_tag = event['ResourceProperties']['EvaluationImageTag']
                      runtime_image_tag = event['ResourceProperties']['RuntimeImageTag']
                      ai_image_tag = event['ResourceProperties']['CostComputeImageTag']
                      
                      # Create EC2 instance
                      response = ec2.run_instances(
                          ImageId='ami-01816d07b1128cd2d' if region == 'us-east-1' else 'ami-093a4ad9a8cc370f4',  # Amazon Linux 2023 AMI
                          InstanceType='t2.large',
                          MinCount=1,
                          MaxCount=1,
                          SubnetId=event['ResourceProperties']['PublicSubnet1'],
                          BlockDeviceMappings=[{
                              'DeviceName': '/dev/xvda',
                              'Ebs': {
                                  'VolumeSize': 24,
                                  'VolumeType': 'gp3'
                              }
                          }],
                          IamInstanceProfile={
                              'Arn': event['ResourceProperties']['InstanceProfileArn']
                          },
                          TagSpecifications=[
                              {
                                  'ResourceType': 'instance',
                                  'Tags': [
                                      {
                                          'Key': 'Name',
                                          'Value': 'ECR-Image-Handler'
                                      },
                                      {
                                          'Key': 'AutoTerminate',
                                          'Value': 'true'
                                      }
                                  ]
                              }
                          ]
                      )
                      
                      instance_id = response['Instances'][0]['InstanceId']
                      
                      # Wait for instance to be running and SSM agent to be ready
                      waiter = ec2.get_waiter('instance_running')
                      waiter.wait(InstanceIds=[instance_id])
                      
                      # Run commands to authenticate with ECR and pull/push images
                      command = f'''#!/bin/bash
                      # Login to ECR
                      aws ecr get-login-password --region {region} | docker login --username AWS --password-stdin {account_id}.dkr.ecr.{region}.amazonaws.com

                      # Create repositories if they don't exist
                      for repo in flotorch-indexing-{table_suffix} flotorch-costcompute-{table_suffix} flotorch-evaluation-{table_suffix} flotorch-app-{table_suffix} flotorch-runtime-{table_suffix} flotorch-retriever-{table_suffix}; do
                          aws ecr describe-repositories --repository-names "$repo" --region "{region}" || aws ecr create-repository --repository-name "$repo" --region "{region}"
                      done

                      # Clone and build from FloTorch repository
                      git clone https://github.com/FissionAI/FloTorch.git
                      cd FloTorch

                      # Build and push Docker images
                      docker build -t "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-app-{table_suffix}:{AppImageTag}" -f app/Dockerfile --push .
                      docker tag "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-app-{table_suffix}:{AppImageTag}" "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-app-{table_suffix}:latest"
                      docker push "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-app-{table_suffix}:latest"

                      docker build -t "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-indexing-{table_suffix}:{IndexingImageTag}" -f indexing/fargate_indexing.Dockerfile --push .
                      docker tag "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-indexing-{table_suffix}:{IndexingImageTag}" "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-indexing-{table_suffix}:latest"
                      docker push "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-indexing-{table_suffix}:latest"

                      docker build -t "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-retriever-{table_suffix}:{RetrieverImageTag}" -f retriever/fargate_retriever.Dockerfile --push .
                      docker tag "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-retriever-{table_suffix}:{RetrieverImageTag}" "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-retriever-{table_suffix}:latest"
                      docker push "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-retriever-{table_suffix}:latest"

                      docker build -t "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-evaluation-{table_suffix}:{EvaluationImageTag}" -f evaluation/fargate_evaluation.Dockerfile --push .
                      docker tag "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-evaluation-{table_suffix}:{EvaluationImageTag}" "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-evaluation-{table_suffix}:latest"
                      docker push "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-evaluation-{table_suffix}:latest"

                      docker build -t "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-runtime-{table_suffix}:{RuntimeImageTag}" -f opensearch/opensearch.Dockerfile --push .
                      docker tag "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-runtime-{table_suffix}:{RuntimeImageTag}" "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-runtime-{table_suffix}:latest"
                      docker push "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-runtime-{table_suffix}:latest"

                      cd lambda_handlers
                      docker build -t "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-costcompute-{table_suffix}:{CostComputeImageTag}" -f cost_handler/Dockerfile --push .
                      docker tag "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-costcompute-{table_suffix}:{CostComputeImageTag}" "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-costcompute-{table_suffix}:latest"
                      docker push "{account_id}.dkr.ecr.{region}.amazonaws.com/flotorch-costcompute-{table_suffix}:latest"

                      cd ..
                      echo "Docker operations completed successfully"
                      '''
                      
                      command_id = ssm.send_command(
                          InstanceIds=[instance_id],
                          DocumentName='AWS-RunShellScript',
                          Parameters={'commands': [command]}
                      )['Command']['CommandId']
                      
                      # Wait for command completion
                      while True:
                          try:
                              result = ssm.get_command_invocation(
                                  CommandId=command_id,
                                  InstanceId=instance_id
                              )
                              if result['Status'] in ['Success', 'Failed', 'Cancelled', 'TimedOut']:
                                  if result['Status'] != 'Success':
                                      raise Exception(f"Command failed with status: {result['Status']}")
                                  break
                              time.sleep(10)
                          except ssm.exceptions.InvocationDoesNotExist:
                              time.sleep(10)
                      
                      # Terminate the instance
                      ec2.terminate_instances(InstanceIds=[instance_id])
                      
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                  else:
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)})

      Runtime: python3.9
      Timeout: 900
      MemorySize: 1024

  DockerPullPushResource:
    Type: Custom::DockerPullPush
    DependsOn: DockerPullPushFunction
    Properties:
      ServiceToken: !GetAtt DockerPullPushFunction.Arn
      TableSuffix: !Ref TableSuffix
      InstanceProfileArn: !GetAtt EC2InstanceProfile.Arn
      IndexingRepositoryUri: !Ref IndexingRepositoryUri
      RetrieverRepositoryUri: !Ref RetrieverRepositoryUri
      AppRepositoryUri: !Ref AppRepositoryUri
      EvaluationRepositoryUri: !Ref EvaluationRepositoryUri
      RuntimeRepositoryUri: !Ref RuntimeRepositoryUri
      CostComputeRepositoryUri: !Ref CostComputeRepositoryUri
      PublicSubnet1: !Ref PublicSubnet1
      PrivateSubnet1: !Ref PrivateSubnet1
      IndexingImageTag: !Ref IndexingImageTag
      RetrieverImageTag: !Ref RetrieverImageTag
      AppImageTag: !Ref AppImageTag
      EvaluationImageTag: !Ref EvaluationImageTag
      RuntimeImageTag: !Ref RuntimeImageTag
      CostComputeImageTag: !Ref CostComputeImageTag

  RuntimeLambdaFunction:
    Type: AWS::Lambda::Function
    DependsOn: DockerPullPushResource
    Properties:
      FunctionName: !Sub flotorch-runtime-${TableSuffix}
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ImageUri: !Sub ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/flotorch-runtime-${TableSuffix}:${RuntimeImageTag}
      PackageType: Image
      MemorySize: 4096
      Timeout: 900
      VpcConfig:
        SubnetIds: !Split [",", !Join [",", !Ref PrivateSubnets]]
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
      Environment:
        Variables:
          DATA_BUCKET: !Ref DataBucketName
          EXECUTION_TABLE: !Ref ExecutionTableName
          EXPERIMENT_TABLE: !Ref ExperimentTableName
          METRICS_TABLE: !Ref MetricsTableName
          MODEL_INVOCATIONS_TABLE: !Ref ModelInvocationsTableName
          opensearch_host: !Ref OpenSearchEndpoint
          opensearch_username: !Ref OpenSearchAdminUser
          opensearch_password: !Ref OpenSearchAdminPassword
          INFERENCE_SYSTEM_PROMPT: "You are a helpful assistant. Use the provided context to answer questions accurately. If you cannot find the answer in the context, say so"
          vector_field_name: "vectors"
          opensearch_serverless: "false"
          aws_region: !Ref AWS::Region

  CostComputeLambdaFunction:
    Type: AWS::Lambda::Function
    DependsOn: DockerPullPushResource
    Properties:
      FunctionName: !Sub flotorch-costcompute-${TableSuffix}
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ImageUri: !Sub ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/flotorch-costcompute-${TableSuffix}:latest
      PackageType: Image
      MemorySize: 4096
      Timeout: 900
      VpcConfig:
        SubnetIds: !Split [",", !Join [",", !Ref PrivateSubnets]]
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
      Environment:
        Variables:
          execution_table: !Ref ExecutionTableName
          experiment_table: !Ref ExperimentTableName
          s3_bucket: !Ref DataBucketName
          bedrock_limit_csv: seed/bedrock_limits_small.csv
          aws_region: !Ref AWS::Region

Outputs:
  RuntimeLambdaArn:
    Description: ARN of the Runtime Lambda function
    Value: !GetAtt RuntimeLambdaFunction.Arn
  CostComputeLambdaArn:
    Description: ARN of the cost compute lambda function
    Value: !GetAtt CostComputeLambdaFunction.Arn
  LambdaRoleArn:
    Description: ARN of the Lambda execution role
    Value: !GetAtt LambdaExecutionRole.Arn
  LambdaSecurityGroupId:
    Description: ID of the Lambda security group
    Value: !Ref LambdaSecurityGroup
